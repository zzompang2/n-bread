[{"/Users/ham/Documents/n-bread/src/App.js":"1","/Users/ham/Documents/n-bread/src/index.js":"2","/Users/ham/Documents/n-bread/src/routes/Calculation.js":"3","/Users/ham/Documents/n-bread/src/routes/Navigation.js":"4","/Users/ham/Documents/n-bread/src/routes/Home.js":"5","/Users/ham/Documents/n-bread/src/routes/About.js":"6","/Users/ham/Documents/n-bread/src/routes/Result.js":"7"},{"size":554,"mtime":1609838236098,"results":"8","hashOfConfig":"9"},{"size":148,"mtime":1609836200517,"results":"10","hashOfConfig":"9"},{"size":8416,"mtime":1609865119784,"results":"11","hashOfConfig":"9"},{"size":260,"mtime":1609750074074,"results":"12","hashOfConfig":"9"},{"size":717,"mtime":1609858187708,"results":"13","hashOfConfig":"9"},{"size":926,"mtime":1609865457955,"results":"14","hashOfConfig":"9"},{"size":7124,"mtime":1609863835190,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"r18660",{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},"/Users/ham/Documents/n-bread/src/App.js",[],"/Users/ham/Documents/n-bread/src/index.js",[],"/Users/ham/Documents/n-bread/src/routes/Calculation.js",[],"/Users/ham/Documents/n-bread/src/routes/Navigation.js",[],"/Users/ham/Documents/n-bread/src/routes/Home.js",[],"/Users/ham/Documents/n-bread/src/routes/About.js",[],"/Users/ham/Documents/n-bread/src/routes/Result.js",["31"],"import React from 'react';\nimport { Link } from 'react-router-dom';\nimport \"./Result.css\";\nimport logo from \"../images/logo_after.png\";\n\nclass Result extends React.Component {\n\t/* 합이 0 이 되는 subset 들로 최대한 나누고,\n\t\t 그 subset 들의 index array 를 반환한다. */\n\tgetMaximumSubsets(paidMoney) {\n\t\tconst money = [...paidMoney];\n\t\tconst subsets = [[]];\t\t\t/* 모든 subset 의 index array */\n\t\tconst result = [];\t\t\t\t/* 합이 0 이 되는 subset 의 index array */\n\n\t\t/* 모든 subset 의 index array 만들기.\n\t\t * 현재까지의 부분집합 + 현재까지의 부분집합에 i 번째 원소를 넣은 부분집합 */\n\t\tfor (let i=0; i<money.length; i++) {\n\t\t\tconst len = subsets.length;\n\t\t\tfor (let j=0; j<len; j++) {\n\t\t\t\tconst subset = [...subsets[j], i];\t/* new subset */\n\t\t\t\tlet sum = 0;\n\n\t\t\t\t/* 길이가 전체의 절반 이상인데 합이 0 이려면,\n\t\t\t\t   이미 구한 RESULT 의 여집합인 경우 뿐이다 */\n\t\t\t\tif (subset.length > money.length/2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* SUBSET 의 총 금액 SUM 을 구한다\n\t\t\t\t   금액이 undefined 인 index 는 이미 RESULT 에 들어간 것이므로 제외 */\n\t\t\t\tfor (let k=0; k<subset.length;) {\n\t\t\t\t\tif (money[subset[k]] !== undefined) {\n\t\t\t\t\t\tsum += money[subset[k]];\n\t\t\t\t\t\tk += 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsubset.splice(k, 1);\n\t\t\t\t}\n\t\t\t\t/* SUM 이 0 인 SUBSET 인 경우 RESULT 에 추가하고\n\t\t\t\t\t 다른 조합에 원소들이 포함되지 않도록 MONEY 값을 undefined 으로 한다.\n\t\t\t\t\t 그리고 I 번째 원소를 포함한 조합은 더이상 있을 수 없으므로 break. */\n\t\t\t\tif (sum === 0 && subset.length !== 0) {\n\t\t\t\t\tresult.push(subset);\n\t\t\t\t\tfor (let k=0; k<subset.length; k++)\n\t\t\t\t\t\tmoney[subset[k]] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsubsets.push(subset);\n\t\t\t}\n\t\t}\n\t\t/* 남은 원소들이 있는 경우 (합은 0 이지만 길이가 전체 길이의 절반 초과인 경우) */\n\t\tconst rest = [];\n\t\tfor (let i=0; i<money.length; i++)\n\t\t\tif (money[i] !== undefined)\n\t\t\t\trest.push(i);\n\t\tif (rest.length !== 0)\n\t\t\tresult.push(rest);\n\n\t\treturn result;\n\t}\n\n\trender() {\n\t\tconst { location: { state } } = this.props;\n\t\tconst { number, people, payments } = state;\n\t\tconst { getMaximumSubsets, goBack } = this;\n\n\t\tconst totalPaidMoney = [];\t\t/* 각자 지불해야 할 총 금액 */\n\n\t\tfor (let i=0; i<number; i++)\n\t\t\ttotalPaidMoney.push(0);\n\t\t\n\t\tfor (let i=0; i<payments.length; i++) {\n\t\t\tconst { payer, joins } = payments[i];\n\t\t\tlet money = Number(payments[i].money);\n\t\t\tlet joinNum = 0;\t/* 해당 지불 항목에 대한 총 참가자 수 */\n\n\t\t\t/* 총 참가자 수를 구한다 */\n\t\t\tfor (let j=0; j<joins.length; j++)\n\t\t\t\tif (joins[j])\n\t\t\t\t\tjoinNum += 1;\n\n\t\t\t/* 나누어 떨어지지 않으면 올림해서 보내기로 한다 */\n\t\t\tconst rest = money % joinNum;\n\t\t\tif (rest !== 0)\n\t\t\t\tmoney += (joinNum - rest);\n\n\t\t\t/* PAYER 는 사용한 금액만큼 제외 */\n\t\t\ttotalPaidMoney[payer] -= money;\n\n\t\t\t/* n 등분하여 각 참가자들의 지불 금액에 추가한다 */\n\t\t\tfor (let j=0; j<joins.length; j++)\n\t\t\t\tif (joins[j])\n\t\t\t\t\ttotalPaidMoney[j] += money / joinNum;\n\t\t}\n\n\t\tconst subsets = getMaximumSubsets(totalPaidMoney);\t/* index array of subset */\n\t\tconst moneyFlows = [];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* payer, payee 쌍의 집합 */\n\n\t\t/* 각 SUBSET 내에서 돈의 이동(from->to)를 구한다.\n\t\t\t SUBSET 내의 money 총합은 0 이므로 SUBSET 내에서만 주고 받아 정산을 \n\t\t\t 끝낼 수 있다. n 명의 사람이 있다면 n-1 번의 송금으로 가능하다. 돈을 보내지\n\t\t\t 않는 한 사람(ROOT)은 총 지출액이 가장 큰 사람으로 정한다. */\n\t\tconsole.log(subsets);\n\t\tfor (let i=0; i<subsets.length; i++) {\n\t\t\tconst subset = subsets[i];\n\t\t\tconst money = [];\n\n\t\t\t/* SUBSET 의 원소(전체 array 에서의 index)에 대응하는 money */\n\t\t\tfor (let j=0; j<subset.length; j++)\n\t\t\t\tmoney.push(totalPaidMoney[subset[j]]);\n\n\t\t\t/* 총 지출액이 가장 큰 사람의 index */\n\t\t\tconst root = money.indexOf(Math.min(...money));\n\n\t\t\t/* SUBSET 내에서 정산이 완료될 때까지 {FROM, TO} 를 구한다 */\n\t\t\twhile (money[root] !== 0) {\n\t\t\t\tlet from, to;\n\n\t\t\t\tfor (let j=0; j<money.length; j++) {\n\t\t\t\t\t/* 돈을 줘야 하는 사람 */\n\t\t\t\t\tif (from === undefined && money[j] > 0) {\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t\t/* ROOT 가 받을 금액보다 작은 경우, ROOT 에게 우선적으로 보낸다 */\n\t\t\t\t\t\tif (money[from] <= Math.abs(money[root]))\n\t\t\t\t\t\t\tto = root;\n\t\t\t\t\t}\n\t\t\t\t\t/* 돈을 보내야 하는 사람 */\n\t\t\t\t\telse if (to === undefined && money[j] < 0 && j !== root)\n\t\t\t\t\t\tto = j;\n\n\t\t\t\t\tif (from !== undefined && to !== undefined)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmoneyFlows.push({from: subset[from], to: subset[to], money: money[from]});\n\t\t\t\tmoney[to] += money[from];\n\t\t\t\tmoney[from] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlet isAllZero = true;\n\t\tfor (let i=0; i<moneyFlows.length; i++) {\n\t\t\tif (moneyFlows[i].money !== 0) {\n\t\t\t\tisAllZero = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\t<div className=\"container\">\n\t\t\t\t<Link\n\t\t\t\t\tto={{ pathname: \"/\" }}>\n\t\t\t\t\t<img className=\"logoImage_small\" src={logo} alt=\"빵\" />\n\t\t\t\t</Link>\n\t\t\t\t\n\t\t\t\t<div className=\"title\">엔빵 완료!</div>\n\t\t\t\t<div className=\"payments\">\n\t\t\t\t\t<div className=\"table__row\">\n\t\t\t\t\t\t<span className=\"bodyText table__id\">번호</span>\n\t\t\t\t\t\t<span className=\"bodyText table__name\">이름</span>\n\t\t\t\t\t\t<span className=\"bodyText table__pay\">총 지불액</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t{people.map(person => (\n\t\t\t\t\t\t<div key={person.id} className=\"table__row\">\n\t\t\t\t\t\t\t<div className=\"table__id whiteBox\">{person.id}</div>\n\t\t\t\t\t\t\t<div className=\"table__name whiteBox\">{person.name}</div>\n\t\t\t\t\t\t\t<div className=\"table__pay whiteBox\">{totalPaidMoney[person.id]}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\n\t\t\t\t<div className=\"empty\" />\n\n\t\t\t\t{isAllZero ?\n\t\t\t\t<div className=\"bodyText\">정산할 게 없네요! 이렇게 깔끔할 수가!</div>\n\t\t\t\t:\n\t\t\t\t<div>\n\t\t\t\t\t<div className=\"bodyText\">돈 보내주세요</div>\n\t\t\t\t\t<div className=\"moneyFlow\">\n\t\t\t\t\t\t<div className=\"table__row\">\n\t\t\t\t\t\t\t<span className=\"bodyText table__id\">번호</span>\n\t\t\t\t\t\t\t<span className=\"bodyText table__name\">보내는 이</span>\n\t\t\t\t\t\t\t<span className=\"bodyText table__pay\">금액</span>\n\t\t\t\t\t\t\t<span className=\"bodyText table__id\">번호</span>\n\t\t\t\t\t\t\t<span className=\"bodyText table__name\">받는 이</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\n\t\t\t\t\t\t{moneyFlows.map((flow, idx) => (\n\t\t\t\t\t\t\t<div key={idx} className=\"table__row\">\n\t\t\t\t\t\t\t\t<div className=\"table__id whiteBox\">{flow.from}</div>\n\t\t\t\t\t\t\t\t<div className=\"table__name whiteBox\">{people[flow.from].name}</div>\n\t\t\t\t\t\t\t\t<div className=\"table__pay whiteBox\">{flow.money}원</div>\n\t\t\t\t\t\t\t\t<div className=\"table__id whiteBox\">{flow.to}</div>\n\t\t\t\t\t\t\t\t<div className=\"table__name whiteBox\">{people[flow.to].name}</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t}\n\t\t\t\t<div className=\"empty\" />\n\t\t\t\t\n\t\t\t\t<div className=\"navButton\">\n\t\t\t\t\t<Link\n\t\t\t\t\t\tclassName=\"navButton__link\"\n\t\t\t\t\t\tto={{\n\t\t\t\t\t\t\tpathname: \"/calculation\",\n\t\t\t\t\t\t\tstate: {\n\t\t\t\t\t\t\t\tnumber,\n\t\t\t\t\t\t\t\tpeople,\n\t\t\t\t\t\t\t\tpayments\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t◀ 수정하기\n\t\t\t\t\t</Link>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default Result;",{"ruleId":"32","severity":1,"message":"33","line":64,"column":30,"nodeType":"34","messageId":"35","endLine":64,"endColumn":36},"no-unused-vars","'goBack' is assigned a value but never used.","Identifier","unusedVar"]